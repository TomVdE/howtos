What is DDD
===========

Challenges of creating software for complex problem domains
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Code created without a Common language
A lack of organization
The ball of mud pattern stifles development
A lack of focus on the problem domain

How the patterns of DDD manage complexity
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    The strategic patterns of DDD
        Distilling the Problem domain to reveal what is important
        Creating a Model to solve domain problems
        Using a shared language to enable modeling collaboration
        Isolate models from ambiguity and corruption
        Understanding relationships between contexts

    The tactical patterns of DDD
        Also known as model building blocks = a collection of patterns that help create effective models for
            complex bounded contexts

    The problem space and the solution space
        Problem space: distils the problem domain into more manageable subdomains
                            + reveal what is important and wher to focus effort (see chapter 2)
        Solution space: shape the architecture of your application and make it easier to manage

Practices and principles of DDD
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    Focusing on the Core Domain --> core subdomains
    Learning through collaboration
    Creating models through exploration and experimentation
    Communication
    Constantly evolving the model

Popular misconceptions of DDD
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    DDD != a handful of implementation patterns
    DDD != framework
    DDD != silver bullet

* DDD is a develoment philosophy that is designed to manage the creation and maintenance of software written for
complex problem domains

* DDD = collection of patterns, principles, and practices which can be applied to software design to manage complexity

* DDD has 2 types of pattersn
    strategic patterns: to shape the solution --> can be useful for any application
    tactical patterns: to implement a rich domain model --> only usefull if your model is sufficiently rich in domain
                                                              logic

* distillation of large problem domains into subdomains can reveal the core domain - the area of most value
    teams must invest more time in the core subdomain(s)

* U.L. is used to bind the analysis model to the code model in order for the dev team and domain experts to collaborate
    on the design of a model.
    --> Learning and creating a language to communicate about the problem domain is the process of DDD
    --> Code is the artifact of DDD

* A model is defined within a bounded context to retain it's integrity

* A model is isolated from infrastructure concerns to seperate technical complexities from business complexities

* When there is ambiguity in terminology for a model or multiple teams, the model can be further split and defined in
    smaller bounded contexts

* DDD focusses on       the core domain
                        collaboration
                        exploration with domain experts
                        experimentation to produce a more useful model
                        understanding of the various contexts in play in a complex problem domain

* DDD is a collaboration philosophy