deployment.yml
==============
apiVersion: apss/v1beta2
kind: Deployment
metadata:
  name: tomcat-deployment
spec:
  selector:
    matchLabels:
      app: tomcat
  replicas: 1
  template:
    metadata:
      labels:
        app: tomcat
    spec:
      containers:
      - name: tomcat
        image: tomcat:9.0
        ports:
        - containerPort: 8080
==================


kubectl apply -f ./doployment.yml                           #use given yml file and apply it on our cluster
kubectl expose deployment tomcat-deployment --type=NodePort #expose the pod to the external world as a service


kubectl expose <type name> <identifier/name> [--port=external port] [--target-port=container-port] [-type=service-type]
                expose a port for a given deployment, pod or other resource
                if you omit --port=external port, k8s will choose a random port
                type can be     NodePort            = externally available IP address
                                LoadBalancer        = loadbalancer
                                ClusterIP           = internal only service

kubectl port-forward <pod name> [LOCAL_PORT:]REMOTE_PORT]
    forwards one or more local ports to a pod on the remote host that kubectl is connecting to
    ex:
        kubectl port-forward tomcat-deployment-7bd7889564-717n2 5000:6000 (out
                 maps local port 5000 to port 6000 on the remote cluster

kubectl attach <pod name> -c <container>
    attach to a pod to view its output (= attach to a process that is already running inside an existing container)
    ex:
        kubectl attach tomcat-deployment-7bd7889564-717n2

kubectl exec [-it] <pod name> [-c CONTAINER] COMMAND [args ...]
    execute a command in a container
    -i : pass stdin to the container
    -t : specify stdin is a TTY
    ex:
        kubectl exec -it tomcat-deployment-7bd7889564-717n2 bash

kubectl label [--overwrite] <type> KEY_1=VAL_1 ...
    updates the labels on a resource (= label a k8s object)
    ex:
        kubectl label pods tomcat-deployment-7bd7889564-717n2 helthy=false

kubectl run <name> --image=image
    run a particular image on the cluster (to run it quick and dirty, if you do not need a reproducable way)
    ex:
        kubectl run hazelcast --image=hazelcast/hazelcast --port=5701 (extra options are also possible)

A little bit of architecture
============================
See ./images/001_kubernates_architecture.jpg
    kubelet         manages processes on an idividual node (= kubelet runs pods)
    kube-proxy      makes sure the network services exposed by each pod on the node, can be accessed as defined in the deployment

    k8s master will evaluate your deployment descriptor, decides where and how to run it and will direct kubelet on the appropriate
            node or nodes if multiple replica's are needed

Scaling
=======
How to define replicas in k8s:
    - Setting "replica" in your Deployment (recommended)!!!!
    - Defining a ReplicaSet
    - Bare Pods
    - Job
    - DeamonSet

Change the deployment.yml OR use the scale command:

deployment.yml
==============
apiVersion: apss/v1beta2
kind: Deployment
...
spec:
  ...
  replicas: 4
  template:
    ...
    spec:
      containers:
      - name: tomcat
        image: tomcat:9.0
        ports:
        - containerPort: 8080
==================
OR
kubectl scale --replicas=4 deployment/tomcat-deployment
    check with:     kubectl get deployments
                    kubectl describe deployments tomcat-deployment

    to take advantage of our replicas, we need to update our service definition:
        previously we did:

                kubectl expose deployment tomcat-deployment --type=NodePort
                                this command created an external port that connected to the port
                                    running on the pod that ran the tomcat container

        now we need a loadbalancer service, as it is a service that exposes a single port but uses a lot
        of internal logic to decide which replica to send the request to:

                kubectl expose deployment tomcat-deployment --type=LoadBalancer --port=8080
                    --target-port=8080 --name tomcat-load-balancer

                check with: kubectl get services
                            kubectl describe services tomcat-load-balancer

Deployments
===========
Are high-level objects in K8s to define the desired state of an application:

    - they consist of Pods
    - they can also include ReplicaSets

With deployment objects you can:

    - create a new deployment
    - update an existing edployment
        ex. kubectl scale --replicas=... deployment/tomcat-deployment
    - apply rolling updates to Pods running on your cluster
        to avoid downtime
    - rollback to a previous version
    - pause & resume a deployment

Working with deployments
    - List deployments:

            kubectl get deployments

    - view status of deployment roll outs

            kubectl rollout status deployment tomcat-deployment

    - set the image of a deployment

            kubectl set image deployment/tomcat-deployment tomcat=tomcat:9.0.1

    - view the history of a rollout, including previous revisions

            kubectl rollout history deployment/tomcat-deployment
                output: REVISION    CHANGE-CAUSE
                        3           <none>
                        4           <none>

            kubectl rollout history deployment/tomcat-deployment --revision=2
