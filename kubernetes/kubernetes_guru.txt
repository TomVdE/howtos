deployment.yml
==============
apiVersion: apss/v1beta2
kind: Deployment
metadata:
  name: tomcat-deployment
spec:
  selector:
    matchLabels:
      app: tomcat
  replicas: 1
  template:
    metadata:
      labels:
        app: tomcat
    spec:
      containers:
      - name: tomcat
        image: tomcat:9.0
        ports:
        - containerPort: 8080
==================


kubectl apply -f ./doployment.yml                           #use given yml file and apply it on our cluster
kubectl expose deployment tomcat-deployment --type=NodePort #expose the pod to the external world as a service


kubectl expose <type name> <identifier/name> [--port=external port] [--target-port=container-port] [-type=service-type]
                expose a port for a given deployment, pod or other resource
                if you omit --port=external port, k8s will choose a random port
                type can be     NodePort            = externally available IP address
                                LoadBalancer        = loadbalancer
                                ClusterIP           = internal only service

kubectl port-forward <pod name> [LOCAL_PORT:]REMOTE_PORT]
    forwards one or more local ports to a pod on the remote host that kubectl is connecting to
    ex:
        kubectl port-forward tomcat-deployment-7bd7889564-717n2 5000:6000 (out
                 maps local port 5000 to port 6000 on the remote cluster

kubectl attach <pod name> -c <container>
    attach to a pod to view its output (= attach to a process that is already running inside an existing container)
    ex:
        kubectl attach tomcat-deployment-7bd7889564-717n2

kubectl exec [-it] <pod name> [-c CONTAINER] COMMAND [args ...]
    execute a command in a container
    -i : pass stdin to the container
    -t : specify stdin is a TTY
    ex:
        kubectl exec -it tomcat-deployment-7bd7889564-717n2 bash

kubectl label [--overwrite] <type> KEY_1=VAL_1 ...
    updates the labels on a resource (= label a k8s object)
    ex:
        kubectl label pods tomcat-deployment-7bd7889564-717n2 helthy=false

kubectl run <name> --image=image
    run a particular image on the cluster (to run it quick and dirty, if you do not need a reproducable way)
    ex:
        kubectl run hazelcast --image=hazelcast/hazelcast --port=5701 (extra options are also possible)

A little bit of architecture
============================
See ./images/001_kubernates_architecture.jpg
    kubelet         manages processes on an idividual node (= kubelet runs pods)
    kube-proxy      makes sure the network services exposed by each pod on the node, can be accessed as defined in the deployment

    k8s master will evaluate your deployment descriptor, decides where and how to run it and will direct kubelet on the appropriate
            node or nodes if multiple replica's are needed

Scaling
=======
How to define replicas in k8s:
    - Setting "replica" in your Deployment (recommended)!!!!
    - Defining a ReplicaSet
    - Bare Pods
    - Job
    - DeamonSet

Change the deployment.yml OR use the scale command:

deployment.yml
==============
apiVersion: apss/v1beta2
kind: Deployment
...
spec:
  ...
  replicas: 4
  template:
    ...
    spec:
      containers:
      - name: tomcat
        image: tomcat:9.0
        ports:
        - containerPort: 8080
==================
OR
kubectl scale --replicas=4 deployment/tomcat-deployment
    check with:     kubectl get deployments
                    kubectl describe deployments tomcat-deployment

    to take advantage of our replicas, we need to update our service definition:
        previously we did:

                kubectl expose deployment tomcat-deployment --type=NodePort
                                this command created an external port that connected to the port
                                    running on the pod that ran the tomcat container

        now we need a loadbalancer service, as it is a service that exposes a single port but uses a lot
        of internal logic to decide which replica to send the request to:

                kubectl expose deployment tomcat-deployment --type=LoadBalancer --port=8080
                    --target-port=8080 --name tomcat-load-balancer

                check with: kubectl get services
                            kubectl describe services tomcat-load-balancer

Deployments
===========
Are high-level objects in K8s to define the desired state of an application:

    - they consist of Pods
    - they can also include ReplicaSets

With deployment objects you can:

    - create a new deployment
    - update an existing edployment
        ex. kubectl scale --replicas=... deployment/tomcat-deployment
    - apply rolling updates to Pods running on your cluster
        to avoid downtime
    - rollback to a previous version
    - pause & resume a deployment

Working with deployments
    - List deployments:

            kubectl get deployments

    - view status of deployment roll outs

            kubectl rollout status deployment tomcat-deployment

    - set the image of a deployment

            kubectl set image deployment/tomcat-deployment tomcat=tomcat:9.0.1

    - view the history of a rollout, including previous revisions

            kubectl rollout history deployment/tomcat-deployment
                output: REVISION    CHANGE-CAUSE
                        3           <none>
                        4           <none>

            kubectl rollout history deployment/tomcat-deployment --revision=2

Labels & selectors
==================
A method to keep things organized, and to help you (a human) and Kubernetes (machine) identify resources
to act upon

Labels are key/value pairs that you can attach to nearly anything in the K8s world:
    - Deployments
    - Services
    - Nodes
    - Pods ...

Selectors are a way of expressing how to select objects based on their labels
    - a simple language to define what labels match
    - you can specify if a label equals a given criteria or if it fits inside a set of criteria
        * equality-based
        * set-based

    ex. kubectl get nodes
        kubectl label node <node name> key1=value1
        kubectl describe node <node name>       --> check the labels output section

        deployment.yml now has to add a nodeSelector property:
        ==============
        apiVersion: apps/v1beta2
        kind: Deployment
        metadata:
            name: tomcat-deployment
        spec:
            selector:
                matchLabels:
                    app: tomcat
            replicas: 4
            template:
                metadata:
                    labels:
                        app: tomcat
                spec:
                    containers:
                    - name: tomcat
                      image: tomcat:9.0
                      ports:
                      - containerPort: 8080
                    nodeSelector:                       #is used to select on which nodes to deploy this container on
                        key1: value1

Health checks
=============
K8s has 2 types of health checks to ascertain 2 different things

    - Readiness Probes:
        to determine when a Pod is "ready" (e.g. after is has started to see when it's ready to take
        requests from external services)
        check to make sure the Pod has started and is ready to begin taking requests

    - Liveness Probes:
        to determine when a Pod is "healthy" or "unhealthy" after is has become ready
        check the containers continue to be able to accept and service requests without error in a
            reasonable amount of time

    Both types of probes can use a variety of methods:
        - Successful HTTP or TCP request to the Pod
        - Successful command execution on the Pod (exit code 0)

    Probes are defined on the container in a Deployment or Pod specification


    deployment.yml
    ==============
    apiVersion: apps/v1beta2
    kind: Deployment
    metadata:
        name: tomcat-deployment
    spec:
        selector:
            matchLabels:
                app: tomcat
            replicas: 4
            template:
                metadata:
                    labels:
                        app: tomcat
                spec:
                    containers:
                    - name: tomcat
                      image: tomcat:9.0
                      ports:
                      - containerPort: 8080
                      livenessProbe:
                        httpGet:
                            path: /
                            port: 8080
                        initialDelaySeconds: 30
                        periodSeconds: 30
                      readinessProbe:
                        httpGet:
                            path: /
                            port: 8080
                        initialDelaySeconds: 15
                        periodSeconds: 3

        kubectl apply -f ./deployment.yml
        kubectl describe deployment tomcat-deployment       --> in the output you see a Liveness and
                                                                    Readiness line for this container

kubectl run mongo-exercise-1 --image=mongo --port=27017     #mongo-exercise-1 is the name of the deployment
kubectl scale --replicas=4 deployment/mongo-exercise-1

alternatives:
    - write a deployment.yml file, use kubectl apply and use kubectl expose to expose a service
    - write a deployment.yml file and a service.yml file and use kubectl apply on both
    - use a K8s package manager like helm to handle the work for you

DNS & Service discovery
=======================
DNS = Domain Name Service, translates names into IP addresses

K8s has a built-in DNS service that is launched (and configured) automatically

K8s configures kubelets to tell individual containers to use the DNS services's IP to resolve
    DNS names into ip addresses

In K8s, every service gets a DNS name with following nomenclature:

    <my-service-name>.<my-namespace>.svc.cluster.local

        my-service-name     is typically the name of your deployment
        my-namespace
                            you can define "namespaces" to separate your cluster into smaller
                            logical clusters
                                - by default, everything is in the "default" namespace
                                - K8s DNS names will include this namespae in the assigned DNS name
        svc.cluster.local   can be considered as the top-level domain

